#!/bin/bash
unset ANKI_BASE
set -euo pipefail

/usr/bin/caffeinate -i -w $$ &  # keep system awake during this run

# ---- Env ----
export PATH="/opt/homebrew/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:$PATH"
export PYTHONIOENCODING=UTF-8

# ---- Network gate ----
require_network() {
  local tries=6
  while ! /sbin/ping -q -c1 -t1 1.1.1.1 >/dev/null 2>&1 ; do
    tries=$((tries-1))
    [ $tries -le 0 ] && { echo "[net] offline; skipping this run"; return 1; }
    echo "[net] no connectivity; retrying..."
    sleep 10
  done
  return 0
}

# ---- iCloud root (force Mobile Documents; fallback to CloudStorage) ----
ICLOUD_ROOT="$HOME/Library/Mobile Documents/com~apple~CloudDocs"
if [ ! -d "$ICLOUD_ROOT" ]; then
  ICLOUD_ROOT="$HOME/Library/CloudStorage/iCloud Drive"
fi

# ---- Paths ----
export ANKI_BASE="$ICLOUD_ROOT/Portuguese/Anki"
INBOX="$ANKI_DATA_DIR/inbox"
QUICK="$INBOX/quick.jsonl"
TODAY="$(date +%F)"
ROTATE_STAMP="$INBOX/.rotated-$TODAY"
LOGDIR="$ANKI_DATA_DIR/logs"
mkdir -p "$INBOX" "$LOGDIR"
# ---- Guard against stray ~/quick.jsonl (caused by 'touch quick.jsonl' in ~) ----
HOME_SHADOW="$HOME/quick.jsonl"
if [ -f "$HOME_SHADOW" ]; then
  echo "[warn] Found stray $HOME_SHADOW; appending to iCloud inbox and removing it."
  cat "$HOME_SHADOW" >> "$QUICK" 2>/dev/null || true
  rm -f "$HOME_SHADOW" || true
fi

# ---- Log redirection (after paths exist) ----
exec >>"$LOGDIR/pipeline.$TODAY.log" 2>>"$LOGDIR/pipeline.$TODAY.err"
echo "START $(date)"
echo "whoami=$(whoami)"
echo "icloud_root=$ICLOUD_ROOT"
echo "anki_data_dir=$ANKI_DATA_DIR"
echo "quick=$QUICK"

# ---- Single-run lock (avoid overlap) ----
LOCK="$INBOX/.pipeline.lock"
if ! mkdir "$LOCK" 2>/dev/null; then
  echo "[lock] another run is active; exiting."
  exit 0
fi
cleanup() { rmdir "$LOCK" 2>/dev/null || true; rm -f "${SCRATCH:-}" 2>/dev/null || true; }
trap cleanup EXIT

# ---- Cleanup old rotation stamps ----
for f in "$INBOX"/.rotated-*; do
  [ -e "$f" ] || continue
  [ "$(basename "$f")" = ".rotated-$TODAY" ] && continue
  rm -f "$f" || true
done

# ---- OpenAI key from Keychain + sanitize ----
if [[ -z "${OPENAI_API_KEY:-}" ]]; then
  if KEY_FROM_KC="$(security find-generic-password -a "$USER" -s "anki-tools-openai" -w 2>/dev/null)"; then
    OPENAI_API_KEY="$KEY_FROM_KC"
  else
    echo "[err] OPENAI_API_KEY not set and Keychain item 'anki-tools-openai' not found." >&2
    exit 1
  fi
fi
OPENAI_API_KEY="$(printf %s "$OPENAI_API_KEY" | LC_ALL=C tr -d '\r\n' | tr -d '“”‘’')"
export OPENAI_API_KEY
unset OPENAI_BASE_URL OPENAI_API_BASE OPENAI_ORG_ID
echo "key_prefix=${OPENAI_API_KEY:0:6}"

# ---- Bring up AnkiConnect ----
open -gj -a "Anki" || true
require_network || exit 0
for i in {1..20}; do
  if curl -sS --max-time 1 http://127.0.0.1:8765 >/dev/null ; then
    echo "[anki] AnkiConnect reachable."
    break
  fi
  sleep 1
done
if ! curl -sS --max-time 1 http://127.0.0.1:8765 >/dev/null ; then
  echo "[anki] AnkiConnect not reachable; skipping this run"
  exit 0
fi

# ---- READ-ONLY: copy iCloud inbox to local scratch (with Shortcuts fallback) ----
SCRATCH="$(mktemp -t quick_copy.XXXXXX.jsonl)"
if ! /bin/cp -f "$QUICK" "$SCRATCH" 2>/dev/null; then
  echo "[warn] cp from '$QUICK' failed (TCC or empty?). Trying Shortcuts fallback..."
  if command -v /usr/bin/shortcuts >/dev/null 2>&1; then
    # Optional macOS Shortcut named "Read Quick Inbox" that returns file contents as text
    if /usr/bin/shortcuts list | grep -q "^Read Quick Inbox$"; then
      /usr/bin/shortcuts run "Read Quick Inbox" > "$SCRATCH" || echo "[warn] Shortcuts returned no data."
    else
      echo "[warn] No 'Read Quick Inbox' shortcut found; skipping fallback."
    fi
  fi
fi

# ---- Run transformer on the scratch inbox ----
set +e
"$HOME/anki-tools/.venv/bin/python" -u "$HOME/anki-tools/transform_inbox_to_csv.py" \
  --deck "Portuguese Mastery (pt-PT)" \
  --model "GPT Vocabulary Automater" \
  --inbox-file "$SCRATCH"
STATUS=$?
set -e

# ---- Optional: rotate iCloud inbox (default OFF; enable with ROTATE_INBOX=1) ----
if [[ "${ROTATE_INBOX:-0}" == "1" && $STATUS -eq 0 && ! -f "$ROTATE_STAMP" ]]; then
  echo "[rotate] status=$STATUS stamp=$ROTATE_STAMP quick=$QUICK"
  mv -f "$QUICK" "$QUICK.$(date +%H%M%S).bak" 2>/dev/null || true
  : > "$QUICK" || true
  touch "$ROTATE_STAMP" || true
  echo "[rotate] quick.jsonl cleared for $TODAY"
fi

exit "$STATUS"
